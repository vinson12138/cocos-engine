
                (function() {
                    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
                    var __module = nodeEnv ? module : {exports:{}};
                    var __filename = 'engine-dev/cocos2d/core/utils/misc.js';
                    var __require = nodeEnv ? function (request) {
                        return require(request);
                    } : function (request) {
                        return __quick_compile_engine__.require(request, __filename);
                    };
                    function __define (exports, require, module) {
                        if (!nodeEnv) {__quick_compile_engine__.registerModule(__filename, module);}"use strict";

/****************************************************************************
 Copyright (c) 2013-2016 Chukong Technologies Inc.
 Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.

 https://www.cocos.com/

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated engine source code (the "Software"), a limited,
  worldwide, royalty-free, non-assignable, revocable and non-exclusive license
 to use Cocos Creator solely to develop games on your target platforms. You shall
  not use Cocos Creator software for developing other software or tools that's
  used for developing games. You are not granted to publish, distribute,
  sublicense, and/or sell copies of Cocos Creator.

 The software or tools in this License Agreement are licensed, not sold.
 Xiamen Yaji Software Co., Ltd. reserves all rights not expressly granted to you.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
var js = require('../platform/js');
/**
 * misc utilities
 * @class misc
 * @static
 */


var misc = {};

misc.propertyDefine = function (ctor, sameNameGetSets, diffNameGetSets) {
  function define(np, propName, getter, setter) {
    var pd = Object.getOwnPropertyDescriptor(np, propName);

    if (pd) {
      if (pd.get) np[getter] = pd.get;
      if (pd.set && setter) np[setter] = pd.set;
    } else {
      var getterFunc = np[getter];

      if (CC_DEV && !getterFunc) {
        var clsName = cc.Class._isCCClass(ctor) && js.getClassName(ctor) || ctor.name || '(anonymous class)';
        cc.warnID(5700, propName, getter, clsName);
      } else {
        js.getset(np, propName, getterFunc, np[setter]);
      }
    }
  }

  var propName,
      np = ctor.prototype;

  for (var i = 0; i < sameNameGetSets.length; i++) {
    propName = sameNameGetSets[i];
    var suffix = propName[0].toUpperCase() + propName.slice(1);
    define(np, propName, 'get' + suffix, 'set' + suffix);
  }

  for (propName in diffNameGetSets) {
    var getset = diffNameGetSets[propName];
    define(np, propName, getset[0], getset[1]);
  }
};
/**
 * @param {Number} x
 * @return {Number}
 * Constructor
 */


misc.NextPOT = function (x) {
  x = x - 1;
  x = x | x >> 1;
  x = x | x >> 2;
  x = x | x >> 4;
  x = x | x >> 8;
  x = x | x >> 16;
  return x + 1;
}; //var DirtyFlags = m.DirtyFlags = {
//    TRANSFORM: 1 << 0,
//    SIZE: 1 << 1,
//    //Visible:
//    //Color:
//    //Opacity
//    //Cache
//    //Order
//    //Text
//    //Gradient
//    ALL: (1 << 2) - 1
//};
//
//DirtyFlags.WIDGET = DirtyFlags.TRANSFORM | DirtyFlags.SIZE;


if (CC_EDITOR) {
  // use anonymous function here to ensure it will not being hoisted without CC_EDITOR
  misc.tryCatchFunctor_EDITOR = function (funcName) {
    return Function('target', 'try {\n' + '  target.' + funcName + '();\n' + '}\n' + 'catch (e) {\n' + '  cc._throw(e);\n' + '}');
  };
}

misc.BUILTIN_CLASSID_RE = /^(?:cc|dragonBones|sp|ccsg)\..+/;
var BASE64_KEYS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
var BASE64_VALUES = new Array(123); // max char code in base64Keys

for (var i = 0; i < 123; ++i) {
  BASE64_VALUES[i] = 64;
} // fill with placeholder('=') index


for (var _i = 0; _i < 64; ++_i) {
  BASE64_VALUES[BASE64_KEYS.charCodeAt(_i)] = _i;
} // decoded value indexed by base64 char code


misc.BASE64_VALUES = BASE64_VALUES; // set value to map, if key exists, push to array

misc.pushToMap = function (map, key, value, pushFront) {
  var exists = map[key];

  if (exists) {
    if (Array.isArray(exists)) {
      if (pushFront) {
        exists.push(exists[0]);
        exists[0] = value;
      } else {
        exists.push(value);
      }
    } else {
      map[key] = pushFront ? [value, exists] : [exists, value];
    }
  } else {
    map[key] = value;
  }
};
/**
 * !#en Clamp a value between from and to.
 * !#zh
 * 限定浮点数的最大最小值。<br/>
 * 数值大于 max_inclusive 则返回 max_inclusive。<br/>
 * 数值小于 min_inclusive 则返回 min_inclusive。<br/>
 * 否则返回自身。
 * @method clampf
 * @param {Number} value
 * @param {Number} min_inclusive
 * @param {Number} max_inclusive
 * @return {Number}
 * @example
 * var v1 = cc.misc.clampf(20, 0, 20); // 20;
 * var v2 = cc.misc.clampf(-1, 0, 20); //  0;
 * var v3 = cc.misc.clampf(10, 0, 20); // 10;
 */


misc.clampf = function (value, min_inclusive, max_inclusive) {
  if (min_inclusive > max_inclusive) {
    var temp = min_inclusive;
    min_inclusive = max_inclusive;
    max_inclusive = temp;
  }

  return value < min_inclusive ? min_inclusive : value < max_inclusive ? value : max_inclusive;
};
/**
 * !#en Clamp a value between 0 and 1.
 * !#zh 限定浮点数的取值范围为 0 ~ 1 之间。
 * @method clamp01
 * @param {Number} value
 * @return {Number}
 * @example
 * var v1 = cc.misc.clamp01(20);  // 1;
 * var v2 = cc.misc.clamp01(-1);  // 0;
 * var v3 = cc.misc.clamp01(0.5); // 0.5;
 */


misc.clamp01 = function (value) {
  return value < 0 ? 0 : value < 1 ? value : 1;
};
/**
 * Linear interpolation between 2 numbers, the ratio sets how much it is biased to each end
 * @method lerp
 * @param {Number} a number A
 * @param {Number} b number B
 * @param {Number} r ratio between 0 and 1
 * @return {Number}
 * @example {@link cocos2d/core/platform/CCMacro/lerp.js}
 */


misc.lerp = function (a, b, r) {
  return a + (b - a) * r;
};
/**
 * converts degrees to radians
 * @param {Number} angle
 * @return {Number}
 * @method degreesToRadians
 */


misc.degreesToRadians = function (angle) {
  return angle * cc.macro.RAD;
};
/**
 * converts radians to degrees
 * @param {Number} angle
 * @return {Number}
 * @method radiansToDegrees
 */


misc.radiansToDegrees = function (angle) {
  return angle * cc.macro.DEG;
};

cc.misc = module.exports = misc;
                    }
                    if (nodeEnv) {
                        __define(__module.exports, __require, __module);
                    }
                    else {
                        __quick_compile_engine__.registerModuleFunc(__filename, function () {
                            __define(__module.exports, __require, __module);
                        });
                    }
                })();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImVuZ2luZS1kZXYvY29jb3MyZC9jb3JlL3V0aWxzL21pc2MuanMiXSwibmFtZXMiOlsianMiLCJyZXF1aXJlIiwibWlzYyIsInByb3BlcnR5RGVmaW5lIiwiY3RvciIsInNhbWVOYW1lR2V0U2V0cyIsImRpZmZOYW1lR2V0U2V0cyIsImRlZmluZSIsIm5wIiwicHJvcE5hbWUiLCJnZXR0ZXIiLCJzZXR0ZXIiLCJwZCIsIk9iamVjdCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImdldCIsInNldCIsImdldHRlckZ1bmMiLCJDQ19ERVYiLCJjbHNOYW1lIiwiY2MiLCJDbGFzcyIsIl9pc0NDQ2xhc3MiLCJnZXRDbGFzc05hbWUiLCJuYW1lIiwid2FybklEIiwiZ2V0c2V0IiwicHJvdG90eXBlIiwiaSIsImxlbmd0aCIsInN1ZmZpeCIsInRvVXBwZXJDYXNlIiwic2xpY2UiLCJOZXh0UE9UIiwieCIsIkNDX0VESVRPUiIsInRyeUNhdGNoRnVuY3Rvcl9FRElUT1IiLCJmdW5jTmFtZSIsIkZ1bmN0aW9uIiwiQlVJTFRJTl9DTEFTU0lEX1JFIiwiQkFTRTY0X0tFWVMiLCJCQVNFNjRfVkFMVUVTIiwiQXJyYXkiLCJjaGFyQ29kZUF0IiwicHVzaFRvTWFwIiwibWFwIiwia2V5IiwidmFsdWUiLCJwdXNoRnJvbnQiLCJleGlzdHMiLCJpc0FycmF5IiwicHVzaCIsImNsYW1wZiIsIm1pbl9pbmNsdXNpdmUiLCJtYXhfaW5jbHVzaXZlIiwidGVtcCIsImNsYW1wMDEiLCJsZXJwIiwiYSIsImIiLCJyIiwiZGVncmVlc1RvUmFkaWFucyIsImFuZ2xlIiwibWFjcm8iLCJSQUQiLCJyYWRpYW5zVG9EZWdyZWVzIiwiREVHIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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eEIsR0FBd0NOLEtBQUssR0FBR08sYUFBUixHQUF3QlAsS0FBeEIsR0FBZ0NPLGFBQS9FO0FBQ0gsQ0FQRDtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBcEQsSUFBSSxDQUFDc0QsT0FBTCxHQUFlLFVBQVVULEtBQVYsRUFBaUI7QUFDNUIsU0FBT0EsS0FBSyxHQUFHLENBQVIsR0FBWSxDQUFaLEdBQWdCQSxLQUFLLEdBQUcsQ0FBUixHQUFZQSxLQUFaLEdBQW9CLENBQTNDO0FBQ0gsQ0FGRDtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E3QyxJQUFJLENBQUN1RCxJQUFMLEdBQVksVUFBVUMsQ0FBVixFQUFhQyxDQUFiLEVBQWdCQyxDQUFoQixFQUFtQjtBQUMzQixTQUFPRixDQUFDLEdBQUcsQ0FBQ0MsQ0FBQyxHQUFHRCxDQUFMLElBQVVFLENBQXJCO0FBQ0gsQ0FGRDtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0ExRCxJQUFJLENBQUMyRCxnQkFBTCxHQUF3QixVQUFVQyxLQUFWLEVBQWlCO0FBQ3JDLFNBQU9BLEtBQUssR0FBRzFDLEVBQUUsQ0FBQzJDLEtBQUgsQ0FBU0MsR0FBeEI7QUFDSCxDQUZEO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTlELElBQUksQ0FBQytELGdCQUFMLEdBQXdCLFVBQVVILEtBQVYsRUFBaUI7QUFDckMsU0FBT0EsS0FBSyxHQUFHMUMsRUFBRSxDQUFDMkMsS0FBSCxDQUFTRyxHQUF4QjtBQUNILENBRkQ7O0FBSUE5QyxFQUFFLENBQUNsQixJQUFILEdBQVVpRSxNQUFNLENBQUNDLE9BQVAsR0FBaUJsRSxJQUEzQiIsInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gQ29weXJpZ2h0IChjKSAyMDEzLTIwMTYgQ2h1a29uZyBUZWNobm9sb2dpZXMgSW5jLlxuIENvcHlyaWdodCAoYykgMjAxNy0yMDE4IFhpYW1lbiBZYWppIFNvZnR3YXJlIENvLiwgTHRkLlxuXG4gaHR0cHM6Ly93d3cuY29jb3MuY29tL1xuXG4gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZW5naW5lIHNvdXJjZSBjb2RlICh0aGUgXCJTb2Z0d2FyZVwiKSwgYSBsaW1pdGVkLFxuICB3b3JsZHdpZGUsIHJveWFsdHktZnJlZSwgbm9uLWFzc2lnbmFibGUsIHJldm9jYWJsZSBhbmQgbm9uLWV4Y2x1c2l2ZSBsaWNlbnNlXG4gdG8gdXNlIENvY29zIENyZWF0b3Igc29sZWx5IHRvIGRldmVsb3AgZ2FtZXMgb24geW91ciB0YXJnZXQgcGxhdGZvcm1zLiBZb3Ugc2hhbGxcbiAgbm90IHVzZSBDb2NvcyBDcmVhdG9yIHNvZnR3YXJlIGZvciBkZXZlbG9waW5nIG90aGVyIHNvZnR3YXJlIG9yIHRvb2xzIHRoYXQnc1xuICB1c2VkIGZvciBkZXZlbG9waW5nIGdhbWVzLiBZb3UgYXJlIG5vdCBncmFudGVkIHRvIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsXG4gIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiBDb2NvcyBDcmVhdG9yLlxuXG4gVGhlIHNvZnR3YXJlIG9yIHRvb2xzIGluIHRoaXMgTGljZW5zZSBBZ3JlZW1lbnQgYXJlIGxpY2Vuc2VkLCBub3Qgc29sZC5cbiBYaWFtZW4gWWFqaSBTb2Z0d2FyZSBDby4sIEx0ZC4gcmVzZXJ2ZXMgYWxsIHJpZ2h0cyBub3QgZXhwcmVzc2x5IGdyYW50ZWQgdG8geW91LlxuXG4gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiBUSEUgU09GVFdBUkUuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxudmFyIGpzID0gcmVxdWlyZSgnLi4vcGxhdGZvcm0vanMnKTtcblxuLyoqXG4gKiBtaXNjIHV0aWxpdGllc1xuICogQGNsYXNzIG1pc2NcbiAqIEBzdGF0aWNcbiAqL1xudmFyIG1pc2MgPSB7fTtcblxubWlzYy5wcm9wZXJ0eURlZmluZSA9IGZ1bmN0aW9uIChjdG9yLCBzYW1lTmFtZUdldFNldHMsIGRpZmZOYW1lR2V0U2V0cykge1xuICAgIGZ1bmN0aW9uIGRlZmluZSAobnAsIHByb3BOYW1lLCBnZXR0ZXIsIHNldHRlcikge1xuICAgICAgICB2YXIgcGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG5wLCBwcm9wTmFtZSk7XG4gICAgICAgIGlmIChwZCkge1xuICAgICAgICAgICAgaWYgKHBkLmdldCkgbnBbZ2V0dGVyXSA9IHBkLmdldDtcbiAgICAgICAgICAgIGlmIChwZC5zZXQgJiYgc2V0dGVyKSBucFtzZXR0ZXJdID0gcGQuc2V0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGdldHRlckZ1bmMgPSBucFtnZXR0ZXJdO1xuICAgICAgICAgICAgaWYgKENDX0RFViAmJiAhZ2V0dGVyRnVuYykge1xuICAgICAgICAgICAgICAgIHZhciBjbHNOYW1lID0gKGNjLkNsYXNzLl9pc0NDQ2xhc3MoY3RvcikgJiYganMuZ2V0Q2xhc3NOYW1lKGN0b3IpKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Rvci5uYW1lIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnKGFub255bW91cyBjbGFzcyknO1xuICAgICAgICAgICAgICAgIGNjLndhcm5JRCg1NzAwLCBwcm9wTmFtZSwgZ2V0dGVyLCBjbHNOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGpzLmdldHNldChucCwgcHJvcE5hbWUsIGdldHRlckZ1bmMsIG5wW3NldHRlcl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBwcm9wTmFtZSwgbnAgPSBjdG9yLnByb3RvdHlwZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNhbWVOYW1lR2V0U2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwcm9wTmFtZSA9IHNhbWVOYW1lR2V0U2V0c1tpXTtcbiAgICAgICAgdmFyIHN1ZmZpeCA9IHByb3BOYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBwcm9wTmFtZS5zbGljZSgxKTtcbiAgICAgICAgZGVmaW5lKG5wLCBwcm9wTmFtZSwgJ2dldCcgKyBzdWZmaXgsICdzZXQnICsgc3VmZml4KTtcbiAgICB9XG4gICAgZm9yIChwcm9wTmFtZSBpbiBkaWZmTmFtZUdldFNldHMpIHtcbiAgICAgICAgdmFyIGdldHNldCA9IGRpZmZOYW1lR2V0U2V0c1twcm9wTmFtZV07XG4gICAgICAgIGRlZmluZShucCwgcHJvcE5hbWUsIGdldHNldFswXSwgZ2V0c2V0WzFdKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBDb25zdHJ1Y3RvclxuICovXG5taXNjLk5leHRQT1QgPSBmdW5jdGlvbiAoeCkge1xuICAgIHggPSB4IC0gMTtcbiAgICB4ID0geCB8ICh4ID4+IDEpO1xuICAgIHggPSB4IHwgKHggPj4gMik7XG4gICAgeCA9IHggfCAoeCA+PiA0KTtcbiAgICB4ID0geCB8ICh4ID4+IDgpO1xuICAgIHggPSB4IHwgKHggPj4gMTYpO1xuICAgIHJldHVybiB4ICsgMTtcbn07XG5cbi8vdmFyIERpcnR5RmxhZ3MgPSBtLkRpcnR5RmxhZ3MgPSB7XG4vLyAgICBUUkFOU0ZPUk06IDEgPDwgMCxcbi8vICAgIFNJWkU6IDEgPDwgMSxcbi8vICAgIC8vVmlzaWJsZTpcbi8vICAgIC8vQ29sb3I6XG4vLyAgICAvL09wYWNpdHlcbi8vICAgIC8vQ2FjaGVcbi8vICAgIC8vT3JkZXJcbi8vICAgIC8vVGV4dFxuLy8gICAgLy9HcmFkaWVudFxuLy8gICAgQUxMOiAoMSA8PCAyKSAtIDFcbi8vfTtcbi8vXG4vL0RpcnR5RmxhZ3MuV0lER0VUID0gRGlydHlGbGFncy5UUkFOU0ZPUk0gfCBEaXJ0eUZsYWdzLlNJWkU7XG5cbmlmIChDQ19FRElUT1IpIHtcbiAgICAvLyB1c2UgYW5vbnltb3VzIGZ1bmN0aW9uIGhlcmUgdG8gZW5zdXJlIGl0IHdpbGwgbm90IGJlaW5nIGhvaXN0ZWQgd2l0aG91dCBDQ19FRElUT1JcblxuICAgIG1pc2MudHJ5Q2F0Y2hGdW5jdG9yX0VESVRPUiA9IGZ1bmN0aW9uIChmdW5jTmFtZSkge1xuICAgICAgICByZXR1cm4gRnVuY3Rpb24oJ3RhcmdldCcsXG4gICAgICAgICAgICAndHJ5IHtcXG4nICtcbiAgICAgICAgICAgICcgIHRhcmdldC4nICsgZnVuY05hbWUgKyAnKCk7XFxuJyArXG4gICAgICAgICAgICAnfVxcbicgK1xuICAgICAgICAgICAgJ2NhdGNoIChlKSB7XFxuJyArXG4gICAgICAgICAgICAnICBjYy5fdGhyb3coZSk7XFxuJyArXG4gICAgICAgICAgICAnfScpO1xuICAgIH07XG59XG5cbm1pc2MuQlVJTFRJTl9DTEFTU0lEX1JFID0gL14oPzpjY3xkcmFnb25Cb25lc3xzcHxjY3NnKVxcLi4rLztcblxuXG52YXIgQkFTRTY0X0tFWVMgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nO1xudmFyIEJBU0U2NF9WQUxVRVMgPSBuZXcgQXJyYXkoMTIzKTsgLy8gbWF4IGNoYXIgY29kZSBpbiBiYXNlNjRLZXlzXG5mb3IgKGxldCBpID0gMDsgaSA8IDEyMzsgKytpKSBCQVNFNjRfVkFMVUVTW2ldID0gNjQ7IC8vIGZpbGwgd2l0aCBwbGFjZWhvbGRlcignPScpIGluZGV4XG5mb3IgKGxldCBpID0gMDsgaSA8IDY0OyArK2kpIEJBU0U2NF9WQUxVRVNbQkFTRTY0X0tFWVMuY2hhckNvZGVBdChpKV0gPSBpO1xuXG4vLyBkZWNvZGVkIHZhbHVlIGluZGV4ZWQgYnkgYmFzZTY0IGNoYXIgY29kZVxubWlzYy5CQVNFNjRfVkFMVUVTID0gQkFTRTY0X1ZBTFVFUztcblxuLy8gc2V0IHZhbHVlIHRvIG1hcCwgaWYga2V5IGV4aXN0cywgcHVzaCB0byBhcnJheVxubWlzYy5wdXNoVG9NYXAgPSBmdW5jdGlvbiAobWFwLCBrZXksIHZhbHVlLCBwdXNoRnJvbnQpIHtcbiAgICB2YXIgZXhpc3RzID0gbWFwW2tleV07XG4gICAgaWYgKGV4aXN0cykge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShleGlzdHMpKSB7XG4gICAgICAgICAgICBpZiAocHVzaEZyb250KSB7XG4gICAgICAgICAgICAgICAgZXhpc3RzLnB1c2goZXhpc3RzWzBdKTtcbiAgICAgICAgICAgICAgICBleGlzdHNbMF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGV4aXN0cy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1hcFtrZXldID0gKHB1c2hGcm9udCA/IFt2YWx1ZSwgZXhpc3RzXSA6IFtleGlzdHMsIHZhbHVlXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG1hcFtrZXldID0gdmFsdWU7XG4gICAgfVxufTtcblxuLyoqXG4gKiAhI2VuIENsYW1wIGEgdmFsdWUgYmV0d2VlbiBmcm9tIGFuZCB0by5cbiAqICEjemhcbiAqIOmZkOWumua1rueCueaVsOeahOacgOWkp+acgOWwj+WAvOOAgjxici8+XG4gKiDmlbDlgLzlpKfkuo4gbWF4X2luY2x1c2l2ZSDliJnov5Tlm54gbWF4X2luY2x1c2l2ZeOAgjxici8+XG4gKiDmlbDlgLzlsI/kuo4gbWluX2luY2x1c2l2ZSDliJnov5Tlm54gbWluX2luY2x1c2l2ZeOAgjxici8+XG4gKiDlkKbliJnov5Tlm57oh6rouqvjgIJcbiAqIEBtZXRob2QgY2xhbXBmXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSB7TnVtYmVyfSBtaW5faW5jbHVzaXZlXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4X2luY2x1c2l2ZVxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGV4YW1wbGVcbiAqIHZhciB2MSA9IGNjLm1pc2MuY2xhbXBmKDIwLCAwLCAyMCk7IC8vIDIwO1xuICogdmFyIHYyID0gY2MubWlzYy5jbGFtcGYoLTEsIDAsIDIwKTsgLy8gIDA7XG4gKiB2YXIgdjMgPSBjYy5taXNjLmNsYW1wZigxMCwgMCwgMjApOyAvLyAxMDtcbiAqL1xubWlzYy5jbGFtcGYgPSBmdW5jdGlvbiAodmFsdWUsIG1pbl9pbmNsdXNpdmUsIG1heF9pbmNsdXNpdmUpIHtcbiAgICBpZiAobWluX2luY2x1c2l2ZSA+IG1heF9pbmNsdXNpdmUpIHtcbiAgICAgICAgdmFyIHRlbXAgPSBtaW5faW5jbHVzaXZlO1xuICAgICAgICBtaW5faW5jbHVzaXZlID0gbWF4X2luY2x1c2l2ZTtcbiAgICAgICAgbWF4X2luY2x1c2l2ZSA9IHRlbXA7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZSA8IG1pbl9pbmNsdXNpdmUgPyBtaW5faW5jbHVzaXZlIDogdmFsdWUgPCBtYXhfaW5jbHVzaXZlID8gdmFsdWUgOiBtYXhfaW5jbHVzaXZlO1xufTtcblxuLyoqXG4gKiAhI2VuIENsYW1wIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxLlxuICogISN6aCDpmZDlrprmta7ngrnmlbDnmoTlj5blgLzojIPlm7TkuLogMCB+IDEg5LmL6Ze044CCXG4gKiBAbWV0aG9kIGNsYW1wMDFcbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGV4YW1wbGVcbiAqIHZhciB2MSA9IGNjLm1pc2MuY2xhbXAwMSgyMCk7ICAvLyAxO1xuICogdmFyIHYyID0gY2MubWlzYy5jbGFtcDAxKC0xKTsgIC8vIDA7XG4gKiB2YXIgdjMgPSBjYy5taXNjLmNsYW1wMDEoMC41KTsgLy8gMC41O1xuICovXG5taXNjLmNsYW1wMDEgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPCAwID8gMCA6IHZhbHVlIDwgMSA/IHZhbHVlIDogMTtcbn07XG5cbi8qKlxuICogTGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiAyIG51bWJlcnMsIHRoZSByYXRpbyBzZXRzIGhvdyBtdWNoIGl0IGlzIGJpYXNlZCB0byBlYWNoIGVuZFxuICogQG1ldGhvZCBsZXJwXG4gKiBAcGFyYW0ge051bWJlcn0gYSBudW1iZXIgQVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgbnVtYmVyIEJcbiAqIEBwYXJhbSB7TnVtYmVyfSByIHJhdGlvIGJldHdlZW4gMCBhbmQgMVxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGV4YW1wbGUge0BsaW5rIGNvY29zMmQvY29yZS9wbGF0Zm9ybS9DQ01hY3JvL2xlcnAuanN9XG4gKi9cbm1pc2MubGVycCA9IGZ1bmN0aW9uIChhLCBiLCByKSB7XG4gICAgcmV0dXJuIGEgKyAoYiAtIGEpICogcjtcbn07XG5cbi8qKlxuICogY29udmVydHMgZGVncmVlcyB0byByYWRpYW5zXG4gKiBAcGFyYW0ge051bWJlcn0gYW5nbGVcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBtZXRob2QgZGVncmVlc1RvUmFkaWFuc1xuICovXG5taXNjLmRlZ3JlZXNUb1JhZGlhbnMgPSBmdW5jdGlvbiAoYW5nbGUpIHtcbiAgICByZXR1cm4gYW5nbGUgKiBjYy5tYWNyby5SQUQ7XG59O1xuXG4vKipcbiAqIGNvbnZlcnRzIHJhZGlhbnMgdG8gZGVncmVlc1xuICogQHBhcmFtIHtOdW1iZXJ9IGFuZ2xlXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAbWV0aG9kIHJhZGlhbnNUb0RlZ3JlZXNcbiAqL1xubWlzYy5yYWRpYW5zVG9EZWdyZWVzID0gZnVuY3Rpb24gKGFuZ2xlKSB7XG4gICAgcmV0dXJuIGFuZ2xlICogY2MubWFjcm8uREVHO1xufTtcblxuY2MubWlzYyA9IG1vZHVsZS5leHBvcnRzID0gbWlzYzsiXSwic291cmNlUm9vdCI6Ii8ifQ==